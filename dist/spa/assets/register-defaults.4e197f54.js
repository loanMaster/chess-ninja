import{C as p}from"./chess-board.interface.005362a6.js";import{u as o,n as l}from"./exercise.store.a03c0b34.js";import{d as g,C as _,a as y,B as f,o as x,e as m,b2 as C,g as v,u as d,at as h,b3 as S,aj as w,r as u,aC as b}from"./index.acb1a3f4.js";const k={style:{"aspect-ratio":"1","max-width":"100%","max-height":"100%",margin:"auto"}},E=v("div",{class:"g-board"},null,-1),L=[E],O=g({__name:"ExerciseBoard",emits:["square-clicked"],setup(i,{emit:a}){let s;async function e(){const t={draggable:!1,onClick:c=>{a("square-clicked",c)}};s=new p(".g-board",t),await s.initialized.pipe(C(1)).toPromise()}_(async()=>{o().$subscribe(()=>{n()}),await e(),n()});async function n(){s.clear(),s.removeHighlighting(),s.position(r.value.pieces,!1),s.orientation(r.value.orientation);for(const t of r.value.highlightPositive)s.highlight(t);for(const t of r.value.highlightNegative)s.highlight(t,!1)}const r=y(()=>o().board);return f(()=>{s&&s.destroy()}),(t,c)=>(x(),m("div",k,L))}});class P{setVisible(a,s){a&&a.isConnected&&a.style.setProperty("visibility",s?"visible":"hidden")}setDisplay(a,s){a&&a.isConnected&&a.style.setProperty("display",s)}async fadeOut(a,s=.5){a&&a.isConnected&&(await this._animateCSS(a,"fadeOut",s),a.isConnected&&a.classList.contains("fadeOut")&&(a.classList.remove("animated","fadeOut","_x_headShake"),a.style.setProperty("opacity","0")))}async fadeIn(a,s=.5){a&&a.isConnected&&(await this._animateCSS(a,"fadeIn",s),a.isConnected&&a.classList.contains("fadeIn")&&(a.classList.remove("animated","fadeIn","_x_headShake"),a.style.setProperty("opacity","1")))}isAnimating(a,s){return a&&a.isConnected&&a.classList.contains(s),!1}stopAnimations(a){if(a&&a.isConnected){a.style.removeProperty("--animate-duration"),a.classList.remove("animated");const s=[];a.classList.forEach(e=>s.push(e)),s.filter(e=>e.startsWith("_x_")).forEach(e=>{a.classList.remove(e,e.replace("_x_",""))})}}async wiggle(a,s=.5){a&&a.isConnected&&(await this._animateCSS(a,"headShake",s),a.isConnected&&a.classList.remove("animated","headShake","_x_headShake"))}async animateCSS(a,s,e){a&&a.isConnected&&(await this._animateCSS(a,s,e),a.isConnected&&a.classList.remove("animated",s,"_x_"+s))}_animateCSS(a,s,e=.5){return new Promise(n=>{const r=`${s}`;a.classList.add("animated",r,"_x_"+r),e&&a.style.setProperty("--animate-duration",String(e)+"s");function t(c){c.stopPropagation(),a.isConnected&&e&&a.style.removeProperty("--animate-duration"),n("Animation ended")}a.addEventListener("animationend",t,{once:!0})})}}const B={wait:i=>new Promise(a=>setTimeout(a,i)),difficulty:i=>i.params.difficulty,nameOfTheGame:i=>i.params.game,finishExercise:i=>{o().finishExercise(),i.push({name:"score-screen",params:{language:d().language}})},handleMistake:function(i,a){o().strike()&&o().exercise.strikes>=1&&i(),a&&new P().wiggle(a.value)},createExercise:i=>{o().$patch(a=>{a.exercise=l(h().params.game,i)})},prepareNewQuestion:async({inputDisabled:i,revealed:a,router:s})=>(i.value=!0,o().$patch(e=>e.exercise.currentQuestion++),o().exercise.currentQuestion===o().exercise.totalQuestions+1?(await B.wait(200),await o().finishExercise(),await s.push({name:"score-screen",params:{language:d().language}}),!1):(o().$patch(e=>e.exercise.strikes=0),a.value=!1,!0))};function Q(){const i=o(),a=S(),{t:s}=w(),e=h(),n=u(!0),r=u(!1),t=new b;return f(()=>{i.$patch(c=>c.exercise.state="created"),t.next(),t.complete()}),{revealed:r,inputDisabled:n,destroy:t,store:i,$q:a,route:e,t:s}}export{O as _,Q as c,B as e};
